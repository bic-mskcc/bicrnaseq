% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bic_analyze_counts.R
\name{bic.deseq.normalize.htseq.counts}
\alias{bic.deseq.normalize.htseq.counts}
\title{Use DESeq to normalize raw HTSeq counts}
\usage{
bic.deseq.normalize.htseq.counts(formatted.counts = NULL, htseq.file = NULL,
  cds = NULL, key = NULL, min.count = 10, libsizeQ = F,
  percentile = "100\%", fitType = "parametric", method = "per-condition",
  sharingMode = "maximum")
}
\arguments{
\item{formatted.counts}{matrix containing raw counts from HTSeq. One column per sample,
one row per gene; may be used INSTEAD of htseq.file, but NOT in
conjunction with}

\item{htseq.file}{file containing raw HTSeq counts; One column per sample, one row
per gene; may be used INSTEAD of formatted counts, but NOT in 
conjunction with}

\item{cds}{DESeq countDataSet object; Default: NULL, if null will compute
on the fly}

\item{key}{sample key where column one contains sample ID that matches
that in counts file, and column two contains the condition 
group to which it belongs. Only those samples that are in the 
key matrix will be included in the returned matrices}

\item{min.count}{minimum total number of reads for a gene across samples; Default: 10}

\item{libsizeQ}{logical to indicate we should use library size to normalize counts 
rather than DESeq's method [TO DO: RECHECK THIS]}

\item{percentile}{string indicating percentile to use when normalizing by library size}

\item{fitType}{See DESeq documentation. Default: "parameteric"}

\item{method}{See DESeq documentation. Default: "per-condition"}

\item{sharingMode}{See DESeq documentation. Default: "maximum"#'}
}
\value{
list containing two matrices: one of raw counts and one of
        DESeq-scaled, log2 transformed counts. Column names will have condition appended
}
\description{
Use DESeq scaling method to normalize raw HTSeq counts and return a list containing both 
raw and normalized counts. Takes in either formatted.counts matrix from bic.format.htseq.counts()
OR an HTSeq counts file. Optionally takes in previously generated countDataSet. If not given,
also optionally takes in parameters for generating one. Sample key will be used in generation of
countDataSet but if not given, it will be assumed that all samples belong to one condition group.
}
